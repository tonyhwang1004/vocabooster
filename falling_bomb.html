<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Falling Word Bomb - VocaBooster</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

    :root {
      --primary-color: #6200ea;
      --secondary-color: #03dac6;
      --danger-color: #ff5252;
      --success-color: #00c853;
      --warning-color: #ffab00;
      --bg-color: #212121;
      --text-color: #ffffff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Noto Sans KR', sans-serif;
      background: linear-gradient(135deg, #212121 0%, #424242 100%);
      color: var(--text-color);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;
    }

    #gameContainer {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    #gameHeader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 15px;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
    }

    #scoreBoard, #hpBoard, #levelBoard {
      font-size: 1.2rem;
      font-weight: bold;
      padding: 8px 15px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #scoreBoard {
      background-color: rgba(98, 0, 234, 0.7);
    }

    #hpBoard {
      background-color: rgba(255, 82, 82, 0.7);
    }

    #levelBoard {
      background-color: rgba(255, 171, 0, 0.7);
    }

    #scoreBadge, #hpBadge, #levelBadge {
      display: inline-block;
      width: 30px;
      height: 30px;
      line-height: 30px;
      text-align: center;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
    }

    .ground {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 80px;
      background: linear-gradient(to top, rgba(255, 0, 0, 0.8), transparent);
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 1.2rem;
      z-index: 10;
    }

    #inputContainer {
      position: fixed;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 500px;
      z-index: 100;
    }

    #inputBox {
      width: 100%;
      padding: 15px;
      border-radius: 25px;
      border: none;
      background: rgba(255, 255, 255, 0.9);
      font-size: 1.2rem;
      color: #000;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      transition: all 0.3s;
    }

    #inputBox:focus {
      outline: none;
      box-shadow: 0 0 0 3px var(--primary-color);
      background: white;
    }

    .bomb {
      position: absolute;
      padding: 15px 20px;
      border-radius: 50%;
      font-weight: bold;
      text-align: center;
      font-size: 1.2rem;
      color: white;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      animation: pulse 1s infinite alternate;
      display: flex;
      justify-content: center;
      align-items: center;
      transform-origin: center;
      z-index: 5;
      min-width: 70px;
      min-height: 70px;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      100% {
        transform: scale(1.05);
      }
    }

    .explode {
      animation: explode 0.5s forwards;
    }

    @keyframes explode {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      100% {
        transform: scale(2);
        opacity: 0;
      }
    }

    .correct {
      animation: correct 0.5s forwards;
    }

    @keyframes correct {
      0% {
        transform: scale(1);
        background-color: var(--success-color);
        opacity: 1;
      }
      100% {
        transform: scale(1.5);
        background-color: var(--success-color);
        opacity: 0;
      }
    }

    #gameOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200;
      flex-direction: column;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
    }

    #gameOverlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    #countdown {
      font-size: 5rem;
      font-weight: bold;
      color: white;
      animation: pulse-text 1s infinite;
    }

    @keyframes pulse-text {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.2);
        opacity: 0.8;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    #gameMessage {
      font-size: 1.5rem;
      margin-top: 20px;
      text-align: center;
      padding: 0 20px;
    }

    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
    }

    #pauseBtn {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 101;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    #pauseBtn:hover {
      background: rgba(255, 255, 255, 0.4);
    }

    #hint {
      position: fixed;
      bottom: 160px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 171, 0, 0.8);
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 1rem;
      z-index: 100;
      text-align: center;
      max-width: 80%;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #hint.show {
      opacity: 1;
    }

    #heartContainer {
      display: flex;
      gap: 5px;
    }

    .heart {
      color: #ff5252;
      font-size: 1.5rem;
    }

    .shake {
      animation: shake 0.5s;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
      20%, 40%, 60%, 80% { transform: translateX(5px); }
    }

    /* Responsive design */
    @media (max-width: 768px) {
      #gameHeader {
        padding: 10px;
      }

      #scoreBoard, #hpBoard, #levelBoard {
        font-size: 1rem;
        padding: 6px 10px;
      }

      #scoreBadge, #hpBadge, #levelBadge {
        width: 25px;
        height: 25px;
        line-height: 25px;
      }

      .bomb {
        font-size: 1rem;
        padding: 10px 15px;
        min-width: 60px;
        min-height: 60px;
      }

      #inputBox {
        padding: 12px;
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="gameHeader">
      <div id="scoreBoard">
        <i class="fas fa-star"></i>
        점수: <span id="scoreBadge">0</span>
      </div>
      <div id="levelBoard">
        <i class="fas fa-rocket"></i>
        레벨: <span id="levelBadge">1</span>
      </div>
      <div id="hpBoard">
        <div id="heartContainer"></div>
      </div>
    </div>

    <button id="pauseBtn"><i class="fas fa-pause"></i></button>

    <div id="inputContainer">
      <input type="text" id="inputBox" placeholder="단어의 뜻을 입력하고 Enter" autocomplete="off" />
    </div>

    <div class="ground">
      <i class="fas fa-exclamation-triangle"></i> 바닥에 닿기 전에 맞추세요! <i class="fas fa-exclamation-triangle"></i>
    </div>

    <div id="hint"></div>
  </div>

  <div id="gameOverlay">
    <div id="countdown">3</div>
    <div id="gameMessage">준비하세요!</div>
  </div>

  <script>
    // GitHub Pages 기본 경로 설정
    function getBasePath() {
      const pathname = window.location.pathname;
      if (pathname.endsWith('.html')) {
        return pathname.substring(0, pathname.lastIndexOf('/') + 1);
      }
      return pathname.endsWith('/') ? pathname : pathname + '/';
    }
    const BASE_PATH = getBasePath();

    // URL 파라미터 파싱
    const urlParams = new URLSearchParams(window.location.search);
    const bookFolder = urlParams.get('folder') || urlParams.get('book') || '';
    const lessonList = urlParams.get('lessons') ? urlParams.get('lessons').split(',') : [];
    const testMode = urlParams.get('mode') || 'kor_to_eng'; // 기본값: 한영

    // 게임 변수 초기화
    let words = [];
    let score = 0;
    let hp = 3;
    let index = 0;
    let activeBombs = [];
    let gameActive = false;
    let level = 1;
    let bombSpeed = 1;
    let bombInterval = 5000;
    let bombTimer = null;
    let gameIsPaused = false;
    let showHint = false;
    let hintTimeout = null;
    let wordsDropped = 0;
    const maxLevel = 5;

    // 단어 데이터 로드 함수
    async function loadWords() {
      try {
        let allWords = [];
        
        console.log('BASE_PATH:', BASE_PATH);
        console.log('Book folder:', bookFolder);
        console.log('Lessons:', lessonList);
        console.log('Test mode:', testMode);

        if (lessonList.length === 0 || !bookFolder) {
          // URL 파라미터가 없으면 테스트용 단어 사용
          console.log('URL 파라미터 없음, 테스트 단어 사용');
          words = [
            {word: "apple", meaning: "사과"},
            {word: "book", meaning: "책"},
            {word: "computer", meaning: "컴퓨터"},
            {word: "friend", meaning: "친구"},
            {word: "school", meaning: "학교"},
            {word: "water", meaning: "물"},
            {word: "teacher", meaning: "선생님"},
            {word: "student", meaning: "학생"},
            {word: "pencil", meaning: "연필"},
            {word: "phone", meaning: "전화기"}
          ];
          return;
        }

        for (const lesson of lessonList) {
          const pathsToTry = [
            BASE_PATH + `data/books/${bookFolder}/${lesson}.json`,
            `./data/books/${bookFolder}/${lesson}.json`,
            `/vocabooster/data/books/${bookFolder}/${lesson}.json`
          ];
          
          let loaded = false;
          for (const url of pathsToTry) {
            try {
              console.log('Trying URL:', url);
              const response = await fetch(url);
              if (response.ok) {
                const data = await response.json();
                // JSON 데이터 변환 - 모드에 따라 다르게 설정
                // 한영(kor_to_eng): 한글이 떨어지고 → 영어 입력
                // 영한(eng_to_kor): 영어가 떨어지고 → 한글 입력
                const convertedWords = data.map(item => ({
                  word: testMode === 'kor_to_eng' ? item.kor : item.eng,
                  meaning: testMode === 'kor_to_eng' ? item.eng : item.kor
                }));
                allWords = allWords.concat(convertedWords);
                console.log('Success! Loaded', data.length, 'words from', url);
                loaded = true;
                break;
              }
            } catch (e) {
              console.log('Failed:', url, e.message);
            }
          }
          
          if (!loaded) {
            console.warn('Could not load lesson:', lesson);
          }
        }

        if (allWords.length > 0) {
          words = shuffleArray(allWords);
          console.log('총', words.length, '개의 단어 로드 완료');
        } else {
          // 단어 로드 실패 시 테스트 단어 사용
          console.log('단어 로드 실패, 테스트 단어 사용');
          words = [
            {word: "apple", meaning: "사과"},
            {word: "book", meaning: "책"},
            {word: "computer", meaning: "컴퓨터"},
            {word: "friend", meaning: "친구"},
            {word: "school", meaning: "학교"},
            {word: "water", meaning: "물"},
            {word: "teacher", meaning: "선생님"},
            {word: "student", meaning: "학생"},
            {word: "pencil", meaning: "연필"},
            {word: "phone", meaning: "전화기"}
          ];
        }
      } catch (error) {
        console.error('단어 로드 오류:', error);
        words = [
          {word: "apple", meaning: "사과"},
          {word: "book", meaning: "책"},
          {word: "computer", meaning: "컴퓨터"},
          {word: "friend", meaning: "친구"},
          {word: "school", meaning: "학교"}
        ];
      }
    }

    // 배열 셔플
    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // 레벨에 따른 속도 설정 (더 완만하게 조정)
    const levelSpeeds = {
      1: 5000,  // 5초
      2: 4200,  // 4.2초
      3: 3500,  // 3.5초
      4: 3000,  // 3초
      5: 2500   // 2.5초
    };

    // DOM 요소 가져오기
    const gameContainer = document.getElementById('gameContainer');
    const inputBox = document.getElementById('inputBox');
    const scoreBadge = document.getElementById('scoreBadge');
    const levelBadge = document.getElementById('levelBadge');
    const heartContainer = document.getElementById('heartContainer');
    const gameOverlay = document.getElementById('gameOverlay');
    const countdown = document.getElementById('countdown');
    const gameMessage = document.getElementById('gameMessage');
    const pauseBtn = document.getElementById('pauseBtn');
    const hintElement = document.getElementById('hint');

    // 현재 레벨에 따른 속도 반환
    function getCurrentSpeed() {
      return levelSpeeds[level];
    }

    // 하트 UI 업데이트 함수
    function updateHearts() {
      heartContainer.innerHTML = '';
      for (let i = 0; i < hp; i++) {
        const heart = document.createElement('div');
        heart.className = 'heart';
        heart.innerHTML = '<i class="fas fa-heart"></i>';
        heartContainer.appendChild(heart);
      }
    }

    // 색상 배열
    const bombColors = [
      '#6200ea', '#3949ab', '#00897b', '#43a047', '#ffb300',
      '#ff5722', '#d81b60', '#8e24aa', '#5e35b1', '#1e88e5'
    ];

    // 단어 생성 간격 증가 함수 (속도 증가 완화)
    function increaseLevel() {
      if (level < maxLevel) {
        level++;
        levelBadge.textContent = level;
        // 폭탄 속도 더 완만하게 증가 (0.5 → 0.2)
        bombSpeed += 0.2;
        
        // 레벨업 효과
        const levelUpMsg = document.createElement('div');
        levelUpMsg.textContent = `LEVEL UP! ${level}`;
        levelUpMsg.style.position = 'fixed';
        levelUpMsg.style.top = '50%';
        levelUpMsg.style.left = '50%';
        levelUpMsg.style.transform = 'translate(-50%, -50%)';
        levelUpMsg.style.color = '#ffab00';
        levelUpMsg.style.fontSize = '3rem';
        levelUpMsg.style.fontWeight = 'bold';
        levelUpMsg.style.zIndex = '150';
        levelUpMsg.style.textShadow = '0 0 10px rgba(255, 171, 0, 0.8)';

        document.body.appendChild(levelUpMsg);

        // 애니메이션 후 제거
        setTimeout(() => {
          levelUpMsg.style.transition = 'all 0.5s';
          levelUpMsg.style.opacity = '0';
          levelUpMsg.style.transform = 'translate(-50%, -50%) scale(1.5)';

          setTimeout(() => {
            levelUpMsg.remove();
          }, 500);
        }, 1000);
      }
    }

    // 단어 드롭 함수 (레벨업 주기 늘림)
    function dropWord() {
      if (!gameActive || gameIsPaused) return;
      
      // 단어를 다 사용했으면 처음부터 다시
      if (index >= words.length) {
        index = 0;
      }
      
      createBomb();
      wordsDropped++;
      
      // 10개 단어마다 레벨 증가 (5개→10개로 늘림)
      if (wordsDropped % 10 === 0) {
        increaseLevel();
      }
      
      // 다음 단어 생성 예약
      bombTimer = setTimeout(dropWord, getCurrentSpeed());
    }

    // 폭탄 생성 함수
    function createBomb() {
      if (!gameActive || gameIsPaused) return;
      
      // 단어를 다 사용했으면 처음부터 다시
      if (index >= words.length) {
        index = 0;
      }

      const word = words[index];
      const bombEl = document.createElement('div');
      bombEl.className = "bomb";
      bombEl.innerText = word.word;
      bombEl.dataset.meaning = word.meaning;
      bombEl.dataset.index = index;

      // 랜덤 위치 및 크기 설정
      const size = Math.floor(Math.random() * 30) + 70; // 70px ~ 100px
      bombEl.style.width = `${size}px`;
      bombEl.style.height = `${size}px`;

      // 랜덤 좌표 설정 (화면 너비 내에서)
      const maxX = window.innerWidth - size;
      const randomX = Math.floor(Math.random() * maxX);
      bombEl.style.left = `${randomX}px`;
      bombEl.style.top = "-100px"; // 화면 상단 밖에서 시작

      // 랜덤 색상 설정
      const colorIndex = Math.floor(Math.random() * bombColors.length);
      bombEl.style.backgroundColor = bombColors[colorIndex];

      // 폭탄 모양 추가
      bombEl.innerHTML = `
        <span style="position: relative; z-index: 2;">${word.word}</span>
        <span style="position: absolute; top: -10px; right: -5px; font-size: 0.8rem; background: rgba(0,0,0,0.6); padding: 3px 6px; border-radius: 10px;">
          <i class="fas fa-fire"></i>
        </span>
      `;

      gameContainer.appendChild(bombEl);
      activeBombs.push({
        element: bombEl,
        word: word,
        top: -100,
        index: index
      });

      index++;
    }

    // 폭탄 애니메이션 함수
    function animateBombs() {
      if (!gameActive || gameIsPaused) return;

      const bombsToRemove = [];
      
      activeBombs.forEach((bomb, bombIndex) => {
        bomb.top += bombSpeed;
        bomb.element.style.top = bomb.top + 'px';

        // 바닥에 닿았는지 확인
        if (bomb.top >= window.innerHeight - 150) {
          // 폭발 애니메이션 추가
          bomb.element.classList.add('explode');
          createExplosionParticles(bomb.element);
          
          // 제거 목록에 추가
          bombsToRemove.push(bombIndex);

          // HP 감소
          hp--;
          updateHearts();

          // 게임 오버 체크
          if (hp <= 0) {
            endGame();
          }
        }
      });
      
      // 역순으로 제거 (배열 인덱스 문제 방지)
      for (let i = bombsToRemove.length - 1; i >= 0; i--) {
        const idx = bombsToRemove[i];
        const bomb = activeBombs[idx];
        
        // 애니메이션 후 제거
        setTimeout(() => {
          bomb.element.remove();
        }, 500);
        
        activeBombs.splice(idx, 1);
      }

      // 애니메이션 반복
      if (gameActive) {
        requestAnimationFrame(animateBombs);
      }
    }

    // 폭발 파티클 생성 함수
    function createExplosionParticles(element) {
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';

        // 랜덤 색상
        particle.style.backgroundColor = bombColors[Math.floor(Math.random() * bombColors.length)];

        // 시작 위치
        particle.style.left = `${centerX}px`;
        particle.style.top = `${centerY}px`;

        document.body.appendChild(particle);

        // 랜덤 방향으로 이동
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 3;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;

        let x = 0;
        let y = 0;
        let opacity = 1;

        function animateParticle() {
          if (opacity <= 0) {
            particle.remove();
            return;
          }

          x += vx;
          y += vy;
          opacity -= 0.02;

          particle.style.transform = `translate(${x}px, ${y}px)`;
          particle.style.opacity = opacity;

          requestAnimationFrame(animateParticle);
        }

        requestAnimationFrame(animateParticle);
      }
    }

    // 정답 확인 함수
    function checkAnswer(input) {
      input = input.trim().toLowerCase();
      if (!input) return;

      let correctBomb = null;

      // 모든 활성 폭탄 확인
      for (let i = 0; i < activeBombs.length; i++) {
        const bomb = activeBombs[i];
        const correctMeaning = bomb.word.meaning.trim().toLowerCase();
        
        // 여러 답변 지원 (쉼표로 구분된 경우)
        const possibleAnswers = correctMeaning.split(',').map(a => a.trim());
        
        // 정확히 일치하거나, 가능한 답변 중 하나와 일치하면 정답
        const isCorrect = possibleAnswers.some(answer => {
          // 정확히 일치
          if (input === answer) return true;
          // 입력이 정답을 포함하거나 정답이 입력을 포함
          if (input.includes(answer) || answer.includes(input)) return true;
          // 공백/특수문자 제거 후 비교
          const cleanInput = input.replace(/[^가-힣a-z0-9]/g, '');
          const cleanAnswer = answer.replace(/[^가-힣a-z0-9]/g, '');
          if (cleanInput === cleanAnswer) return true;
          return false;
        });

        if (isCorrect) {
          correctBomb = bomb;
          break;
        }
      }

      if (correctBomb) {
        // 정답 처리
        correctBomb.element.classList.add('correct');

        // 정답 애니메이션 후 제거
        setTimeout(() => {
          const index = activeBombs.indexOf(correctBomb);
          if (index > -1) {
            correctBomb.element.remove();
            activeBombs.splice(index, 1);
          }
        }, 500);

        // 점수 증가
        score += 10 * level;
        scoreBadge.textContent = score;

        // 힌트 숨기기
        if (showHint) {
          hideHint();
        }
      } else {
        // 오답 효과 (입력창 흔들기)
        inputBox.classList.add('shake');
        setTimeout(() => {
          inputBox.classList.remove('shake');
        }, 500);
      }
    }

    // 카운트다운 시작 함수 (카운트다운 문제 수정)
    function startCountdown() {
      console.log("카운트다운 시작");
      
      // 게임 오버레이 활성화
      gameOverlay.classList.add('active');
      
      // 카운트다운 시작값
      countdown.textContent = "3";
      gameMessage.textContent = "준비하세요!";
      
      // 직접 타이머 설정 대신 중첩된 setTimeout 사용
      setTimeout(function() {
        countdown.textContent = "2";
        console.log("카운트다운: 2");
        
        setTimeout(function() {
          countdown.textContent = "1";
          console.log("카운트다운: 1");
          
          setTimeout(function() {
            countdown.textContent = "시작!";
            console.log("카운트다운: 시작!");
            
            setTimeout(function() {
              gameOverlay.classList.remove('active');
              startGame();
            }, 800);
          }, 1000);
        }, 1000);
      }, 1000);
    }

    // 게임 시작 함수 (초기 속도 감소)
    function startGame() {
      console.log("게임 시작");
      score = 0;
      hp = 3;
      index = 0;
      level = 1;
      wordsDropped = 0;
      bombSpeed = 1;  // 초기 속도 감소 (2 → 1)
      bombInterval = 5000;
      gameActive = true;
      gameIsPaused = false;
      activeBombs = [];

      // UI 초기화
      scoreBadge.textContent = score;
      levelBadge.textContent = level;
      updateHearts();

      // 기존 폭탄 제거
      document.querySelectorAll('.bomb').forEach(b => b.remove());
      document.querySelectorAll('.particle').forEach(p => p.remove());

      // 게임 시작
      dropWord();
      requestAnimationFrame(animateBombs);

      // 입력창 포커스
      inputBox.focus();

      // 일정 시간 후 힌트 표시
      setTimeout(() => {
        if (gameActive && !gameIsPaused && activeBombs.length > 0) {
          showHintForRandomBomb();
        }
      }, 10000);
    }

    // 게임 종료 함수
    function endGame() {
      gameActive = false;
      clearTimeout(bombTimer);

      // 100점 만점으로 점수 환산 (랭킹 시스템과 일치시킴)
      let scorePercentage = Math.min(Math.round((score / (words.length * 10)) * 100), 100);

      // 게임 오버 메시지 표시
      gameOverlay.classList.add('active');
      countdown.textContent = '';
      gameMessage.innerHTML = `
        <h2>게임 종료!</h2>
        <p>최종 점수: ${score} 점</p>
        <p>환산 점수: ${scorePercentage}% (${scorePercentage}/100)</p>
        <p>최고 레벨: ${level}</p>
        <button id="restartBtn" style="
          margin-top: 20px;
          padding: 10px 20px;
          background: var(--primary-color);
          color: white;
          border: none;
          border-radius: 20px;
          font-size: 1.2rem;
          cursor: pointer;
        ">다시 시작</button>
        <button id="rankingBtn" style="
          margin-top: 10px;
          padding: 10px 20px;
          background: #28a745;
          color: white;
          border: none;
          border-radius: 20px;
          font-size: 1.2rem;
          cursor: pointer;
        ">랭킹 보기</button>
        <button id="homeBtn" style="
          margin-top: 10px;
          padding: 10px 20px;
          background: rgba(255,255,255,0.2);
          color: white;
          border: none;
          border-radius: 20px;
          font-size: 1.2rem;
          cursor: pointer;
        ">홈으로</button>
      `;

      // 버튼 이벤트 연결
      document.getElementById('restartBtn').addEventListener('click', () => {
        gameOverlay.classList.remove('active');
        startCountdown();
      });

      document.getElementById('rankingBtn').addEventListener('click', () => {
        window.location.href = 'ranking.html';
      });

      document.getElementById('homeBtn').addEventListener('click', () => {
        window.location.href = 'index.html';
      });

      // 결과 저장 (localStorage에 저장)
      const gameData = {
        student_name: urlParams.get('name') || '학생',
        book: urlParams.get('book') || '',
        lesson: lessonList.join(','),
        mode: 'eng_to_kor',
        score: scorePercentage,
        total_questions: 100,
        date: new Date().toISOString()
      };

      // localStorage에 결과 저장
      const savedResults = JSON.parse(localStorage.getItem('vocabooster_game_results') || '[]');
      savedResults.push(gameData);
      localStorage.setItem('vocabooster_game_results', JSON.stringify(savedResults));
      console.log('결과 저장 완료:', gameData);
    }

    // 일시정지 함수
    function togglePause() {
      gameIsPaused = !gameIsPaused;

      if (gameIsPaused) {
        pauseBtn.innerHTML = '<i class="fas fa-play"></i>';
        gameOverlay.classList.add('active');
        countdown.textContent = '';
        gameMessage.innerHTML = `
          <h2>일시정지</h2>
          <p>게임을 계속하려면 재생 버튼을 누르세요</p>
        `;
      } else {
        pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        gameOverlay.classList.remove('active');
        inputBox.focus();
      }
    }

    // 랜덤 폭탄 힌트 표시 함수
    function showHintForRandomBomb() {
      if (activeBombs.length === 0 || !gameActive || gameIsPaused) return;

      // 랜덤 폭탄 선택
      const randomBomb = activeBombs[Math.floor(Math.random() * activeBombs.length)];
      const meaning = randomBomb.word.meaning;

      // 힌트 표시 (첫 글자 + 나머지 별표)
      const firstChar = meaning.charAt(0);
      const hint = `힌트: ${firstChar}${'*'.repeat(meaning.length - 1)}`;

      hintElement.textContent = hint;
      hintElement.classList.add('show');
      showHint = true;

      // 힌트 제거 타이머
      clearTimeout(hintTimeout);
      hintTimeout = setTimeout(hideHint, 5000);
    }

    // 힌트 숨기기 함수
    function hideHint() {
      hintElement.classList.remove('show');
      showHint = false;
    }

    // 이벤트 리스너
    inputBox.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && gameActive && !gameIsPaused) {
        checkAnswer(this.value);
        this.value = '';
      }
    });

    pauseBtn.addEventListener('click', togglePause);

    // 윈도우 크기 변경 처리
    window.addEventListener('resize', function() {
      // 화면 크기가 변경되면 활성 폭탄 위치 보정
      activeBombs.forEach(bomb => {
        const rect = bomb.element.getBoundingClientRect();
        if (rect.left > window.innerWidth - rect.width) {
          bomb.element.style.left = `${window.innerWidth - rect.width}px`;
        }
      });
    });

    // 키보드 이벤트 (ESC 키: 일시정지)
    window.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && gameActive) {
        togglePause();
      }
    });

    // 브라우저가 완전히 로드된 후 게임 초기화
    document.addEventListener('DOMContentLoaded', async function() {
      console.log("DOM이 로드되었습니다. 단어를 로드합니다.");
      
      // 먼저 단어 로드
      await loadWords();
      console.log("단어 로드 완료:", words.length, "개");
      
      // 게임 초기화
      updateHearts();
      startCountdown();
    });
  </script>
</body>
</html>
